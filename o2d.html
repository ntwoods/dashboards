<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Cycle Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }
        .card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
            padding: 1.5rem;
        }
        .chart-container {
            position: relative;
            height: 400px; /* Fixed height for charts */
            width: 100%;
        }
        /* Custom scrollbar for table */
        .table-container::-webkit-scrollbar {
            height: 8px;
        }
        .table-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .table-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .table-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Message box styling */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            text-align: center;
            max-width: 90%;
            border: 1px solid #e2e8f0;
        }
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container py-8">
        <h1 class="text-4xl font-bold text-center text-indigo-700 mb-8">Order Cycle Performance Dashboard</h1>

        <!-- Loading Indicator -->
        <div id="loading-indicator" class="hidden fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-white p-6 rounded-lg shadow-lg flex items-center space-x-3">
                <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-500"></div>
                <p class="text-lg text-indigo-700 font-medium">Loading data...</p>
            </div>
        </div>

        <!-- Message Box Container -->
        <div id="message-box-container"></div>

        <!-- Summary Statistics Cards -->
        <section class="mb-8">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Average Stage Durations</h2>
            <div id="summary-cards" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                <!-- Cards will be injected here by JavaScript -->
            </div>
             <p id="no-summary-data" class="hidden text-center text-gray-500 mt-4">No summary data available.</p>
        </section>

        <!-- Filters Section -->
        <section class="mb-8 p-6 card">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Filters & Actions</h2>
            <div class="flex flex-wrap items-center gap-4">
                <div class="flex flex-col flex-grow">
                    <label for="startDate" class="text-sm font-medium text-gray-600 mb-1">Start Date:</label>
                    <input type="date" id="startDate" class="p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="flex flex-col flex-grow">
                    <label for="endDate" class="text-sm font-medium text-gray-600 mb-1">End Date:</label>
                    <input type="date" id="endDate" class="p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <button id="applyFilters" class="mt-auto px-6 py-2 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition duration-200 ease-in-out">Apply Filters</button>
                <button id="resetFilters" class="mt-auto px-6 py-2 bg-gray-300 text-gray-800 font-semibold rounded-md shadow-md hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transition duration-200 ease-in-out">Reset Filters</button>
                <button id="exportCsv" class="mt-auto px-6 py-2 bg-green-600 text-white font-semibold rounded-md shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition duration-200 ease-in-out">Export to CSV</button>
            </div>
        </section>

        <!-- Charts Section -->
        <section class="mb-8 grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div class="card chart-container">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Order-wise Stage Durations (Line Chart)</h2>
                <canvas id="lineChart"></canvas>
                <p id="no-line-chart-data" class="hidden text-center text-gray-500 mt-4">No data available for line chart in the selected range.</p>
            </div>
            <div class="card chart-container">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Order-wise Stage Durations (Bar Chart)</h2>
                <canvas id="barChart"></canvas>
                <p id="no-bar-chart-data" class="hidden text-center text-gray-500 mt-4">No data available for bar chart in the selected range.</p>
            </div>
        </section>

        <!-- Per-Order Breakdown Table -->
        <section class="mb-8">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Per-Order Breakdown</h2>
            <div class="card overflow-x-auto table-container">
                <table id="order-table" class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Dealer Name</th>
                            <!-- Dynamic headers for stages -->
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
                        <!-- Table rows will be injected here by JavaScript -->
                    </tbody>
                </table>
                <p id="no-table-data" class="hidden text-center text-gray-500 mt-4">No order data available for the selected range.</p>
            </div>
        </section>
    </div>

    <script>
        // IMPORTANT: Replace this with your deployed Google Apps Script Web App URL
        const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycby0DIhLjrD-iNreDr3d8OKx1KH9FTcMaAcRXOdgWUnhq3_WdkrHvHmN_aDRdHOs39RpoQ/exec';

        let allOrderData = null; // Stores the raw data from the API, including summaryStats and stageDescriptions
        let filteredOrderData = null; // Stores data after applying filters

        // Chart instances
        let lineChartInstance;
        let barChartInstance;

        // Utility function to show a custom message box instead of alert()
        function showMessageBox(message, type = 'info') {
            const container = document.getElementById('message-box-container');
            // Remove existing message box if any
            if (container.firstChild) {
                container.innerHTML = '';
            }

            const overlay = document.createElement('div');
            overlay.className = 'message-box-overlay';
            overlay.onclick = () => hideMessageBox(); // Click outside to close

            const messageBox = document.createElement('div');
            messageBox.className = 'message-box';
            
            let borderColor = 'border-gray-300';
            let textColor = 'text-gray-800';
            let buttonBg = 'bg-indigo-600 hover:bg-indigo-700';

            if (type === 'error') {
                borderColor = 'border-red-500';
                textColor = 'text-red-700';
                buttonBg = 'bg-red-600 hover:bg-red-700';
            } else if (type === 'success') {
                borderColor = 'border-green-500';
                textColor = 'text-green-700';
                buttonBg = 'bg-green-600 hover:bg-green-700';
            }

            messageBox.innerHTML = `
                <p class="text-lg font-medium mb-4 ${textColor}">${message}</p>
                <button class="px-4 py-2 ${buttonBg} text-white rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 ${type === 'error' ? 'focus:ring-red-500' : 'focus:ring-indigo-500'}">OK</button>
            `;
            messageBox.classList.add(borderColor);

            messageBox.querySelector('button').onclick = () => hideMessageBox();

            container.appendChild(overlay);
            container.appendChild(messageBox);
        }

        // Utility function to hide the custom message box
        function hideMessageBox() {
            const container = document.getElementById('message-box-container');
            container.innerHTML = '';
        }

        // Function to show loading indicator
        function showLoading() {
            document.getElementById('loading-indicator').classList.remove('hidden');
        }

        // Function to hide loading indicator
        function hideLoading() {
            document.getElementById('loading-indicator').classList.add('hidden');
        }

        // Helper to convert HH:MM:SS to milliseconds
        function hmsToMs(hms) {
            if (hms === 'N/A' || !hms) return NaN;
            const parts = hms.split(':').map(Number);
            if (parts.length !== 3 || parts.some(isNaN)) return NaN;
            return (parts[0] * 3600 + parts[1] * 60 + parts[2]) * 1000;
        }

        // Helper to convert milliseconds to seconds for chart scaling
        function msToSeconds(ms) {
            return ms / 1000;
        }

        // Function to fetch data from Apps Script
        async function fetchData() {
            if (APPS_SCRIPT_URL === 'YOUR_APPS_SCRIPT_WEB_APP_URL') {
                showMessageBox("Please replace 'YOUR_APPS_SCRIPT_WEB_APP_URL' in the HTML code with your actual deployed Google Apps Script URL.", 'error');
                return;
            }

            showLoading();
            try {
                const response = await fetch(APPS_SCRIPT_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (data.error) {
                    throw new Error(data.error);
                }
                allOrderData = data;
                filteredOrderData = { ...data }; // Initially, filtered data is a copy of all data
                renderDashboard();
            } catch (error) {
                console.error('Error fetching data:', error);
                showMessageBox(`Failed to load data: ${error.message}. Please ensure the Apps Script URL is correct and deployed with 'Anyone' access.`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Function to render summary cards
        function renderSummaryCards(summaryStats, stageDescriptions) {
            const summaryCardsContainer = document.getElementById('summary-cards');
            const noSummaryDataMessage = document.getElementById('no-summary-data');
            summaryCardsContainer.innerHTML = ''; // Clear previous cards
            noSummaryDataMessage.classList.add('hidden');

            const stageNames = Object.keys(summaryStats);
            if (stageNames.length === 0) {
                noSummaryDataMessage.classList.remove('hidden');
                return;
            }

            stageNames.forEach(stageName => {
                const stats = summaryStats[stageName];
                const descriptiveName = stageDescriptions[stageName] || stageName.replace(/_/g, ' to ').toUpperCase();
                const card = document.createElement('div');
                card.className = 'card flex flex-col items-center justify-center p-4 text-center bg-gradient-to-br from-indigo-50 to-indigo-100';
                card.innerHTML = `
                    <h3 class="text-md font-semibold text-indigo-700 mb-2">${descriptiveName}</h3>
                    <div class="text-3xl font-bold text-indigo-900">${stats.average}</div>
                    <div class="text-sm text-gray-600 mt-2">
                        <p>Min: ${stats.min}</p>
                        <p>Max: ${stats.max}</p>
                        <p>Median: ${stats.median}</p>
                    </div>
                `;
                summaryCardsContainer.appendChild(card);
            });
        }

        // Function to render charts
        function renderCharts(orderWiseDurations, stageDescriptions) {
            const ctxLine = document.getElementById('lineChart').getContext('2d');
            const ctxBar = document.getElementById('barChart').getContext('2d');
            const noLineChartDataMessage = document.getElementById('no-line-chart-data');
            const noBarChartDataMessage = document.getElementById('no-bar-chart-data');

            // Destroy existing chart instances if they exist
            if (lineChartInstance) lineChartInstance.destroy();
            if (barChartInstance) barChartInstance.destroy();

            noLineChartDataMessage.classList.add('hidden');
            noBarChartDataMessage.classList.add('hidden');

            if (orderWiseDurations.length === 0) {
                noLineChartDataMessage.classList.remove('hidden');
                noBarChartDataMessage.classList.remove('hidden');
                return;
            }

            // Use dealerName for labels, falling back to orderTimestamp if dealerName is not present
            const labels = orderWiseDurations.map(order => order.dealerName || order.orderTimestamp || 'N/A');
            // Filter out 'orderTimestamp' and 'dealerName' from stageKeys as they are not durations
            const stageKeys = Object.keys(orderWiseDurations[0] || {}).filter(key => key !== 'orderTimestamp' && key !== 'dealerName');

            const datasets = stageKeys.map((stageKey, index) => {
                // Generate a consistent but distinct color for each stage
                const hue = (index * 137 + 50) % 360; // Use a prime number for better distribution
                const color = `hsl(${hue}, 70%, 60%)`;
                const borderColor = `hsl(${hue}, 70%, 50%)`;
                const descriptiveLabel = stageDescriptions[stageKey] || stageKey.replace(/_/g, ' to ').toUpperCase();

                return {
                    label: descriptiveLabel,
                    data: orderWiseDurations.map(order => msToSeconds(hmsToMs(order[stageKey]))),
                    borderColor: borderColor,
                    backgroundColor: color,
                    fill: false,
                    tension: 0.3,
                    borderWidth: 2,
                    pointRadius: 3,
                    pointBackgroundColor: borderColor
                };
            });

            // Line Chart
            lineChartInstance = new Chart(ctxLine, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false,
                            text: 'Order-wise Stage Durations'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const valueInSeconds = context.raw;
                                    if (isNaN(valueInSeconds)) return `${context.dataset.label}: N/A`;
                                    const hours = Math.floor(valueInSeconds / 3600);
                                    const minutes = Math.floor((valueInSeconds % 3600) / 60);
                                    const seconds = Math.floor(valueInSeconds % 60);
                                    const formatted = [hours, minutes, seconds]
                                        .map(unit => String(unit).padStart(2, '0'))
                                        .join(':');
                                    return `${context.dataset.label}: ${formatted}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Dealer Name' // Changed X-axis title
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Duration (Seconds)'
                            },
                            beginAtZero: true,
                            ticks: {
                                callback: function(value, index, values) {
                                    // Convert seconds back to HH:MM:SS for Y-axis labels
                                    const hours = Math.floor(value / 3600);
                                    const minutes = Math.floor((value % 3600) / 60);
                                    const seconds = Math.floor(value % 60);
                                    return [hours, minutes, seconds]
                                        .map(unit => String(unit).padStart(2, '0'))
                                        .join(':');
                                }
                            }
                        }
                    }
                }
            });

            // Bar Chart
            barChartInstance = new Chart(ctxBar, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: datasets.map(dataset => ({
                        ...dataset,
                        fill: true, // Bars should be filled
                        type: 'bar' // Ensure type is bar for this chart
                    }))
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false,
                            text: 'Order-wise Stage Durations'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const valueInSeconds = context.raw;
                                    if (isNaN(valueInSeconds)) return `${context.dataset.label}: N/A`;
                                    const hours = Math.floor(valueInSeconds / 3600);
                                    const minutes = Math.floor((valueInSeconds % 3600) / 60);
                                    const seconds = Math.floor(valueInSeconds % 60);
                                    const formatted = [hours, minutes, seconds]
                                        .map(unit => String(unit).padStart(2, '0'))
                                        .join(':');
                                    return `${context.dataset.label}: ${formatted}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Dealer Name' // Changed X-axis title
                            },
                            stacked: true // Stack bars if you want to see total duration per order
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Duration (Seconds)'
                            },
                            beginAtZero: true,
                            stacked: true, // Stack bars if you want to see total duration per order
                            ticks: {
                                callback: function(value, index, values) {
                                    const hours = Math.floor(value / 3600);
                                    const minutes = Math.floor((value % 3600) / 60);
                                    const seconds = Math.floor(value % 60);
                                    return [hours, minutes, seconds]
                                        .map(unit => String(unit).padStart(2, '0'))
                                        .join(':');
                                }
                            }
                        }
                    }
                }
            });
        }

        // Function to render the table
        function renderTable(orderWiseDurations, stageDescriptions) {
            const tableHead = document.querySelector('#order-table thead tr');
            const tableBody = document.querySelector('#order-table tbody');
            const noTableDataMessage = document.getElementById('no-table-data');

            // Clear previous content
            // Changed header text from 'Order Timestamp' to 'Dealer Name'
            tableHead.innerHTML = '<th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Dealer Name</th>';
            tableBody.innerHTML = '';
            noTableDataMessage.classList.add('hidden');

            if (orderWiseDurations.length === 0) {
                noTableDataMessage.classList.remove('hidden');
                return;
            }

            // Determine dynamic headers from the first order's keys (excluding orderTimestamp and dealerName)
            const stageKeys = Object.keys(orderWiseDurations[0]).filter(key => key !== 'orderTimestamp' && key !== 'dealerName');
            stageKeys.forEach(key => {
                const th = document.createElement('th');
                th.scope = 'col';
                th.className = 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider';
                th.textContent = stageDescriptions[key] || key.replace(/_/g, ' ').toUpperCase(); // Use descriptive name
                tableHead.appendChild(th);
            });

            // Populate table rows
            orderWiseDurations.forEach(order => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50';

                // Display Dealer Name in the first column
                const dealerNameCell = document.createElement('td');
                dealerNameCell.className = 'px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900';
                dealerNameCell.textContent = order.dealerName || 'N/A'; // Use dealerName
                row.appendChild(dealerNameCell);

                stageKeys.forEach(key => {
                    const cell = document.createElement('td');
                    cell.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-500';
                    cell.textContent = order[key] || 'N/A';
                    row.appendChild(cell);
                });
                tableBody.appendChild(row);
            });
        }

        // Main render function to update all components
        function renderDashboard() {
            if (!filteredOrderData || !filteredOrderData.summaryStats || !filteredOrderData.orderWiseDurations || !filteredOrderData.stageDescriptions) {
                console.warn("Data is not in expected format or is empty.");
                // Optionally show a message box here if initial data fetch fails or is malformed
                return;
            }
            renderSummaryCards(filteredOrderData.summaryStats, filteredOrderData.stageDescriptions);
            renderCharts(filteredOrderData.orderWiseDurations, filteredOrderData.stageDescriptions);
            renderTable(filteredOrderData.orderWiseDurations, filteredOrderData.stageDescriptions);
        }

        // Function to apply date filters
        function applyFilters() {
            const startDateInput = document.getElementById('startDate').value;
            const endDateInput = document.getElementById('endDate').value;

            let tempFilteredDurations = allOrderData.orderWiseDurations;

            if (startDateInput) {
                const startDate = new Date(startDateInput + 'T00:00:00'); // Set to start of the day
                tempFilteredDurations = tempFilteredDurations.filter(order => {
                    const orderDate = new Date(order.orderTimestamp);
                    return orderDate >= startDate;
                });
            }

            if (endDateInput) {
                const endDate = new Date(endDateInput + 'T23:59:59'); // Set to end of the day
                tempFilteredDurations = tempFilteredDurations.filter(order => {
                    const orderDate = new Date(order.orderTimestamp);
                    return orderDate <= endDate;
                });
            }

            // Recalculate summary stats for the filtered data
            const newSummaryStats = {};
            const allFilteredStageDurationsMs = {};
            // Filter out 'orderTimestamp' and 'dealerName' from stageKeys as they are not durations
            const stageKeys = Object.keys(allOrderData.summaryStats); // Use all original stage keys

            stageKeys.forEach(key => {
                allFilteredStageDurationsMs[key] = [];
            });

            tempFilteredDurations.forEach(order => {
                stageKeys.forEach(key => {
                    const durationMs = hmsToMs(order[key]);
                    if (!isNaN(durationMs)) {
                        allFilteredStageDurationsMs[key].push(durationMs);
                    }
                });
            });

            stageKeys.forEach(key => {
                const durations = allFilteredStageDurationsMs[key];
                if (durations.length > 0) {
                    const min = Math.min(...durations);
                    const max = Math.max(...durations);
                    const average = durations.reduce((sum, d) => sum + d, 0) / durations.length;
                    const median = calculateMedian(durations);

                    newSummaryStats[key] = {
                        average: formatDuration(average),
                        min: formatDuration(min),
                        max: formatDuration(max),
                        median: formatDuration(median)
                    };
                } else {
                    newSummaryStats[key] = {
                        average: 'N/A',
                        min: 'N/A',
                        max: 'N/A',
                        median: 'N/A'
                    };
                }
            });


            filteredOrderData = {
                summaryStats: newSummaryStats,
                stageDescriptions: allOrderData.stageDescriptions, // Keep original descriptions
                orderWiseDurations: tempFilteredDurations
            };
            renderDashboard();
        }

        // Helper to calculate median (copied from Apps Script, needed for client-side filtering)
        function calculateMedian(arr) {
            if (arr.length === 0) return 0;
            const sortedArr = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sortedArr.length / 2);

            if (sortedArr.length % 2 === 0) {
                return (sortedArr[mid - 1] + sortedArr[mid]) / 2;
            } else {
                return sortedArr[mid];
            }
        }

        // Helper to format duration (copied from Apps Script, needed for client-side filtering)
        function formatDuration(ms) {
            if (ms === null || isNaN(ms)) return 'N/A';
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            return [hours, minutes, seconds]
                .map(unit => String(unit).padStart(2, '0'))
                .join(':');
        }


        // Function to reset date filters
        function resetFilters() {
            document.getElementById('startDate').value = '';
            document.getElementById('endDate').value = '';
            filteredOrderData = { ...allOrderData }; // Reset to a copy of all data
            renderDashboard();
        }

        // Function to export table data to CSV
        function exportCsv() {
            if (!filteredOrderData || filteredOrderData.orderWiseDurations.length === 0) {
                showMessageBox("No data to export.", 'info');
                return;
            }

            // Headers for CSV: Dealer Name first, then dynamic stages
            const headers = ['Dealer Name'].concat(
                Object.keys(filteredOrderData.orderWiseDurations[0])
                      .filter(key => key !== 'orderTimestamp' && key !== 'dealerName') // Exclude both
                      .map(key => filteredOrderData.stageDescriptions[key] || key.replace(/_/g, ' '))
            );
            let csvContent = headers.join(',') + '\n';

            filteredOrderData.orderWiseDurations.forEach(order => {
                // First column is now Dealer Name
                const row = [order.dealerName || 'N/A'];
                // Filter out 'orderTimestamp' and 'dealerName' when pushing other data
                Object.keys(order).filter(key => key !== 'orderTimestamp' && key !== 'dealerName').forEach(key => {
                    // Ensure N/A values are handled correctly in CSV
                    row.push(order[key] || 'N/A');
                });
                csvContent += row.join(',') + '\n';
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'order_cycle_data.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                showMessageBox("Your browser does not support downloading files directly. Please copy the data manually.", 'info');
            }
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            fetchData(); // Fetch data when the page loads

            document.getElementById('applyFilters').addEventListener('click', applyFilters);
            document.getElementById('resetFilters').addEventListener('click', resetFilters);
            document.getElementById('exportCsv').addEventListener('click', exportCsv);
        });
    </script>
</body>
</html>
